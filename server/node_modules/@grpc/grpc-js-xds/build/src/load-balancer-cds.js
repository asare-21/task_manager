"use strict";
/*
 * Copyright 2020 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.setup = exports.CdsLoadBalancer = void 0;
const grpc_js_1 = require("@grpc/grpc-js");
const xds_client_1 = require("./xds-client");
var UnavailablePicker = grpc_js_1.experimental.UnavailablePicker;
var registerLoadBalancerType = grpc_js_1.experimental.registerLoadBalancerType;
var QueuePicker = grpc_js_1.experimental.QueuePicker;
var parseLoadBalancingConfig = grpc_js_1.experimental.parseLoadBalancingConfig;
const load_balancer_xds_cluster_resolver_1 = require("./load-balancer-xds-cluster-resolver");
const cluster_resource_type_1 = require("./xds-resource-type/cluster-resource-type");
const TRACER_NAME = 'cds_balancer';
function trace(text) {
    grpc_js_1.experimental.trace(grpc_js_1.logVerbosity.DEBUG, TRACER_NAME, text);
}
const TYPE_NAME = 'cds';
class CdsLoadBalancingConfig {
    getLoadBalancerName() {
        return TYPE_NAME;
    }
    toJsonObject() {
        return {
            [TYPE_NAME]: {
                cluster: this.cluster
            }
        };
    }
    constructor(cluster) {
        this.cluster = cluster;
    }
    getCluster() {
        return this.cluster;
    }
    static createFromJson(obj) {
        if (!('cluster' in obj && typeof obj.cluster === 'string')) {
            throw new Error('cds config must have a string field cluster');
        }
        return new CdsLoadBalancingConfig(obj.cluster);
    }
}
function isClusterTreeFullyUpdated(tree, root) {
    const toCheck = [root];
    const visited = new Set();
    while (toCheck.length > 0) {
        const next = toCheck.shift();
        if (visited.has(next)) {
            continue;
        }
        visited.add(next);
        if (!tree[next] || !tree[next].latestUpdate) {
            return false;
        }
        toCheck.push(...tree[next].children);
    }
    return true;
}
function generateDiscoverymechanismForCdsUpdate(config) {
    if (config.type === 'AGGREGATE') {
        throw new Error('Cannot generate DiscoveryMechanism for AGGREGATE cluster');
    }
    return {
        cluster: config.name,
        lrs_load_reporting_server: config.lrsLoadReportingServer,
        max_concurrent_requests: config.maxConcurrentRequests,
        type: config.type,
        eds_service_name: config.edsServiceName,
        dns_hostname: config.dnsHostname,
        outlier_detection: config.outlierDetectionUpdate
    };
}
const RECURSION_DEPTH_LIMIT = 15;
/**
 * Prerequisite: isClusterTreeFullyUpdated(tree, root)
 * @param tree
 * @param root
 */
function getDiscoveryMechanismList(tree, root) {
    const visited = new Set();
    function getDiscoveryMechanismListHelper(node, depth) {
        if (depth > RECURSION_DEPTH_LIMIT) {
            throw new Error('aggregate cluster graph exceeds max depth');
        }
        if (visited.has(node)) {
            return [];
        }
        visited.add(node);
        if (tree[node].children.length > 0) {
            trace('Visit ' + node + ' children: [' + tree[node].children + ']');
            // Aggregate cluster
            const result = [];
            for (const child of tree[node].children) {
                result.push(...getDiscoveryMechanismListHelper(child, depth + 1));
            }
            return result;
        }
        else {
            trace('Visit leaf ' + node);
            // individual cluster
            const config = tree[node].latestUpdate;
            return [generateDiscoverymechanismForCdsUpdate(config)];
        }
    }
    return getDiscoveryMechanismListHelper(root, 0);
}
class CdsLoadBalancer {
    constructor(channelControlHelper, options) {
        this.channelControlHelper = channelControlHelper;
        this.latestCdsUpdate = null;
        this.latestConfig = null;
        this.latestAttributes = {};
        this.xdsClient = null;
        this.clusterTree = {};
        this.updatedChild = false;
        this.childBalancer = new load_balancer_xds_cluster_resolver_1.XdsClusterResolverChildPolicyHandler(channelControlHelper, options);
    }
    reportError(errorMessage) {
        trace('CDS cluster reporting error ' + errorMessage);
        this.channelControlHelper.updateState(grpc_js_1.connectivityState.TRANSIENT_FAILURE, new UnavailablePicker({ code: grpc_js_1.status.UNAVAILABLE, details: errorMessage, metadata: new grpc_js_1.Metadata() }));
    }
    addCluster(cluster) {
        if (cluster in this.clusterTree) {
            return;
        }
        trace('Adding watcher for cluster ' + cluster);
        const watcher = new xds_client_1.Watcher({
            onResourceChanged: (update) => {
                this.clusterTree[cluster].latestUpdate = update;
                if (update.type === 'AGGREGATE') {
                    const children = update.aggregateChildren;
                    trace('Received update for aggregate cluster ' + cluster + ' with children [' + children + ']');
                    this.clusterTree[cluster].children = children;
                    children.forEach(child => this.addCluster(child));
                }
                if (isClusterTreeFullyUpdated(this.clusterTree, this.latestConfig.getCluster())) {
                    let discoveryMechanismList;
                    try {
                        discoveryMechanismList = getDiscoveryMechanismList(this.clusterTree, this.latestConfig.getCluster());
                    }
                    catch (e) {
                        this.reportError(e.message);
                        return;
                    }
                    const rootClusterUpdate = this.clusterTree[this.latestConfig.getCluster()].latestUpdate;
                    const clusterResolverConfig = {
                        xds_cluster_resolver: {
                            discovery_mechanisms: discoveryMechanismList,
                            xds_lb_policy: rootClusterUpdate.lbPolicyConfig
                        }
                    };
                    let parsedClusterResolverConfig;
                    try {
                        parsedClusterResolverConfig = parseLoadBalancingConfig(clusterResolverConfig);
                    }
                    catch (e) {
                        this.reportError(`CDS cluster ${this.latestConfig?.getCluster()} child config parsing failed with error ${e.message}`);
                        return;
                    }
                    trace('Child update config: ' + JSON.stringify(clusterResolverConfig));
                    this.updatedChild = true;
                    this.childBalancer.updateAddressList([], parsedClusterResolverConfig, this.latestAttributes);
                }
            },
            onResourceDoesNotExist: () => {
                trace('Received onResourceDoesNotExist update for cluster ' + cluster);
                if (cluster in this.clusterTree) {
                    this.clusterTree[cluster].latestUpdate = undefined;
                    this.clusterTree[cluster].children = [];
                }
                this.reportError(`CDS resource ${cluster} does not exist`);
                this.childBalancer.destroy();
            },
            onError: (statusObj) => {
                if (!this.updatedChild) {
                    trace('Transitioning to transient failure due to onError update for cluster' + cluster);
                    this.reportError(`xDS request failed with error ${statusObj.details}`);
                }
            }
        });
        this.clusterTree[cluster] = {
            watcher: watcher,
            children: []
        };
        if (this.xdsClient) {
            cluster_resource_type_1.ClusterResourceType.startWatch(this.xdsClient, cluster, watcher);
        }
    }
    removeCluster(cluster) {
        if (!(cluster in this.clusterTree)) {
            return;
        }
        if (this.xdsClient) {
            cluster_resource_type_1.ClusterResourceType.cancelWatch(this.xdsClient, cluster, this.clusterTree[cluster].watcher);
        }
        delete this.clusterTree[cluster];
    }
    clearClusterTree() {
        for (const cluster of Object.keys(this.clusterTree)) {
            this.removeCluster(cluster);
        }
    }
    updateAddressList(endpointList, lbConfig, attributes) {
        if (!(lbConfig instanceof CdsLoadBalancingConfig)) {
            trace('Discarding address list update with unrecognized config ' + JSON.stringify(lbConfig, undefined, 2));
            return;
        }
        trace('Received update with config ' + JSON.stringify(lbConfig, undefined, 2));
        this.latestAttributes = attributes;
        this.xdsClient = attributes.xdsClient;
        /* If the cluster is changing, disable the old watcher before adding the new
         * one */
        if (this.latestConfig && this.latestConfig.getCluster() !== lbConfig.getCluster()) {
            trace('Removing old cluster watchers rooted at ' + this.latestConfig.getCluster());
            this.clearClusterTree();
            this.updatedChild = false;
        }
        if (!this.latestConfig) {
            this.channelControlHelper.updateState(grpc_js_1.connectivityState.CONNECTING, new QueuePicker(this));
        }
        this.latestConfig = lbConfig;
        this.addCluster(lbConfig.getCluster());
    }
    exitIdle() {
        this.childBalancer.exitIdle();
    }
    resetBackoff() {
        this.childBalancer.resetBackoff();
    }
    destroy() {
        trace('Destroying load balancer rooted at cluster named ' + this.latestConfig?.getCluster());
        this.childBalancer.destroy();
        this.clearClusterTree();
    }
    getTypeName() {
        return TYPE_NAME;
    }
}
exports.CdsLoadBalancer = CdsLoadBalancer;
function setup() {
    registerLoadBalancerType(TYPE_NAME, CdsLoadBalancer, CdsLoadBalancingConfig);
}
exports.setup = setup;
//# sourceMappingURL=load-balancer-cds.js.map