"use strict";
// Original file: deps/envoy-api/envoy/config/cluster/v3/cluster.proto
Object.defineProperty(exports, "__esModule", { value: true });
exports._envoy_config_cluster_v3_Cluster_LbSubsetConfig_LbSubsetSelector_LbSubsetSelectorFallbackPolicy = exports._envoy_config_cluster_v3_Cluster_LbSubsetConfig_LbSubsetMetadataFallbackPolicy = exports._envoy_config_cluster_v3_Cluster_LbSubsetConfig_LbSubsetFallbackPolicy = exports._envoy_config_cluster_v3_Cluster_LbPolicy = exports._envoy_config_cluster_v3_Cluster_RingHashLbConfig_HashFunction = exports._envoy_config_cluster_v3_Cluster_DnsLookupFamily = exports._envoy_config_cluster_v3_Cluster_DiscoveryType = exports._envoy_config_cluster_v3_Cluster_ClusterProtocolSelection = void 0;
// Original file: deps/envoy-api/envoy/config/cluster/v3/cluster.proto
var _envoy_config_cluster_v3_Cluster_ClusterProtocolSelection;
(function (_envoy_config_cluster_v3_Cluster_ClusterProtocolSelection) {
    /**
     * Cluster can only operate on one of the possible upstream protocols (HTTP1.1, HTTP2).
     * If :ref:`http2_protocol_options <envoy_v3_api_field_config.cluster.v3.Cluster.http2_protocol_options>` are
     * present, HTTP2 will be used, otherwise HTTP1.1 will be used.
     */
    _envoy_config_cluster_v3_Cluster_ClusterProtocolSelection[_envoy_config_cluster_v3_Cluster_ClusterProtocolSelection["USE_CONFIGURED_PROTOCOL"] = 0] = "USE_CONFIGURED_PROTOCOL";
    /**
     * Use HTTP1.1 or HTTP2, depending on which one is used on the downstream connection.
     */
    _envoy_config_cluster_v3_Cluster_ClusterProtocolSelection[_envoy_config_cluster_v3_Cluster_ClusterProtocolSelection["USE_DOWNSTREAM_PROTOCOL"] = 1] = "USE_DOWNSTREAM_PROTOCOL";
})(_envoy_config_cluster_v3_Cluster_ClusterProtocolSelection = exports._envoy_config_cluster_v3_Cluster_ClusterProtocolSelection || (exports._envoy_config_cluster_v3_Cluster_ClusterProtocolSelection = {}));
// Original file: deps/envoy-api/envoy/config/cluster/v3/cluster.proto
/**
 * Refer to :ref:`service discovery type <arch_overview_service_discovery_types>`
 * for an explanation on each type.
 */
var _envoy_config_cluster_v3_Cluster_DiscoveryType;
(function (_envoy_config_cluster_v3_Cluster_DiscoveryType) {
    /**
     * Refer to the :ref:`static discovery type<arch_overview_service_discovery_types_static>`
     * for an explanation.
     */
    _envoy_config_cluster_v3_Cluster_DiscoveryType[_envoy_config_cluster_v3_Cluster_DiscoveryType["STATIC"] = 0] = "STATIC";
    /**
     * Refer to the :ref:`strict DNS discovery
     * type<arch_overview_service_discovery_types_strict_dns>`
     * for an explanation.
     */
    _envoy_config_cluster_v3_Cluster_DiscoveryType[_envoy_config_cluster_v3_Cluster_DiscoveryType["STRICT_DNS"] = 1] = "STRICT_DNS";
    /**
     * Refer to the :ref:`logical DNS discovery
     * type<arch_overview_service_discovery_types_logical_dns>`
     * for an explanation.
     */
    _envoy_config_cluster_v3_Cluster_DiscoveryType[_envoy_config_cluster_v3_Cluster_DiscoveryType["LOGICAL_DNS"] = 2] = "LOGICAL_DNS";
    /**
     * Refer to the :ref:`service discovery type<arch_overview_service_discovery_types_eds>`
     * for an explanation.
     */
    _envoy_config_cluster_v3_Cluster_DiscoveryType[_envoy_config_cluster_v3_Cluster_DiscoveryType["EDS"] = 3] = "EDS";
    /**
     * Refer to the :ref:`original destination discovery
     * type<arch_overview_service_discovery_types_original_destination>`
     * for an explanation.
     */
    _envoy_config_cluster_v3_Cluster_DiscoveryType[_envoy_config_cluster_v3_Cluster_DiscoveryType["ORIGINAL_DST"] = 4] = "ORIGINAL_DST";
})(_envoy_config_cluster_v3_Cluster_DiscoveryType = exports._envoy_config_cluster_v3_Cluster_DiscoveryType || (exports._envoy_config_cluster_v3_Cluster_DiscoveryType = {}));
// Original file: deps/envoy-api/envoy/config/cluster/v3/cluster.proto
/**
 * When V4_ONLY is selected, the DNS resolver will only perform a lookup for
 * addresses in the IPv4 family. If V6_ONLY is selected, the DNS resolver will
 * only perform a lookup for addresses in the IPv6 family. If AUTO is
 * specified, the DNS resolver will first perform a lookup for addresses in
 * the IPv6 family and fallback to a lookup for addresses in the IPv4 family.
 * This is semantically equivalent to a non-existent V6_PREFERRED option.
 * AUTO is a legacy name that is more opaque than
 * necessary and will be deprecated in favor of V6_PREFERRED in a future major version of the API.
 * If V4_PREFERRED is specified, the DNS resolver will first perform a lookup for addresses in the
 * IPv4 family and fallback to a lookup for addresses in the IPv6 family. i.e., the callback
 * target will only get v6 addresses if there were NO v4 addresses to return.
 * If ALL is specified, the DNS resolver will perform a lookup for both IPv4 and IPv6 families,
 * and return all resolved addresses. When this is used, Happy Eyeballs will be enabled for
 * upstream connections. Refer to :ref:`Happy Eyeballs Support <arch_overview_happy_eyeballs>`
 * for more information.
 * For cluster types other than
 * :ref:`STRICT_DNS<envoy_v3_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STRICT_DNS>` and
 * :ref:`LOGICAL_DNS<envoy_v3_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.LOGICAL_DNS>`,
 * this setting is
 * ignored.
 * [#next-major-version: deprecate AUTO in favor of a V6_PREFERRED option.]
 */
var _envoy_config_cluster_v3_Cluster_DnsLookupFamily;
(function (_envoy_config_cluster_v3_Cluster_DnsLookupFamily) {
    _envoy_config_cluster_v3_Cluster_DnsLookupFamily[_envoy_config_cluster_v3_Cluster_DnsLookupFamily["AUTO"] = 0] = "AUTO";
    _envoy_config_cluster_v3_Cluster_DnsLookupFamily[_envoy_config_cluster_v3_Cluster_DnsLookupFamily["V4_ONLY"] = 1] = "V4_ONLY";
    _envoy_config_cluster_v3_Cluster_DnsLookupFamily[_envoy_config_cluster_v3_Cluster_DnsLookupFamily["V6_ONLY"] = 2] = "V6_ONLY";
    _envoy_config_cluster_v3_Cluster_DnsLookupFamily[_envoy_config_cluster_v3_Cluster_DnsLookupFamily["V4_PREFERRED"] = 3] = "V4_PREFERRED";
    _envoy_config_cluster_v3_Cluster_DnsLookupFamily[_envoy_config_cluster_v3_Cluster_DnsLookupFamily["ALL"] = 4] = "ALL";
})(_envoy_config_cluster_v3_Cluster_DnsLookupFamily = exports._envoy_config_cluster_v3_Cluster_DnsLookupFamily || (exports._envoy_config_cluster_v3_Cluster_DnsLookupFamily = {}));
// Original file: deps/envoy-api/envoy/config/cluster/v3/cluster.proto
/**
 * The hash function used to hash hosts onto the ketama ring.
 */
var _envoy_config_cluster_v3_Cluster_RingHashLbConfig_HashFunction;
(function (_envoy_config_cluster_v3_Cluster_RingHashLbConfig_HashFunction) {
    /**
     * Use `xxHash <https://github.com/Cyan4973/xxHash>`_, this is the default hash function.
     */
    _envoy_config_cluster_v3_Cluster_RingHashLbConfig_HashFunction[_envoy_config_cluster_v3_Cluster_RingHashLbConfig_HashFunction["XX_HASH"] = 0] = "XX_HASH";
    /**
     * Use `MurmurHash2 <https://sites.google.com/site/murmurhash/>`_, this is compatible with
     * std:hash<string> in GNU libstdc++ 3.4.20 or above. This is typically the case when compiled
     * on Linux and not macOS.
     */
    _envoy_config_cluster_v3_Cluster_RingHashLbConfig_HashFunction[_envoy_config_cluster_v3_Cluster_RingHashLbConfig_HashFunction["MURMUR_HASH_2"] = 1] = "MURMUR_HASH_2";
})(_envoy_config_cluster_v3_Cluster_RingHashLbConfig_HashFunction = exports._envoy_config_cluster_v3_Cluster_RingHashLbConfig_HashFunction || (exports._envoy_config_cluster_v3_Cluster_RingHashLbConfig_HashFunction = {}));
// Original file: deps/envoy-api/envoy/config/cluster/v3/cluster.proto
/**
 * Refer to :ref:`load balancer type <arch_overview_load_balancing_types>` architecture
 * overview section for information on each type.
 */
var _envoy_config_cluster_v3_Cluster_LbPolicy;
(function (_envoy_config_cluster_v3_Cluster_LbPolicy) {
    /**
     * Refer to the :ref:`round robin load balancing
     * policy<arch_overview_load_balancing_types_round_robin>`
     * for an explanation.
     */
    _envoy_config_cluster_v3_Cluster_LbPolicy[_envoy_config_cluster_v3_Cluster_LbPolicy["ROUND_ROBIN"] = 0] = "ROUND_ROBIN";
    /**
     * Refer to the :ref:`least request load balancing
     * policy<arch_overview_load_balancing_types_least_request>`
     * for an explanation.
     */
    _envoy_config_cluster_v3_Cluster_LbPolicy[_envoy_config_cluster_v3_Cluster_LbPolicy["LEAST_REQUEST"] = 1] = "LEAST_REQUEST";
    /**
     * Refer to the :ref:`ring hash load balancing
     * policy<arch_overview_load_balancing_types_ring_hash>`
     * for an explanation.
     */
    _envoy_config_cluster_v3_Cluster_LbPolicy[_envoy_config_cluster_v3_Cluster_LbPolicy["RING_HASH"] = 2] = "RING_HASH";
    /**
     * Refer to the :ref:`random load balancing
     * policy<arch_overview_load_balancing_types_random>`
     * for an explanation.
     */
    _envoy_config_cluster_v3_Cluster_LbPolicy[_envoy_config_cluster_v3_Cluster_LbPolicy["RANDOM"] = 3] = "RANDOM";
    /**
     * Refer to the :ref:`Maglev load balancing policy<arch_overview_load_balancing_types_maglev>`
     * for an explanation.
     */
    _envoy_config_cluster_v3_Cluster_LbPolicy[_envoy_config_cluster_v3_Cluster_LbPolicy["MAGLEV"] = 5] = "MAGLEV";
    /**
     * This load balancer type must be specified if the configured cluster provides a cluster
     * specific load balancer. Consult the configured cluster's documentation for whether to set
     * this option or not.
     */
    _envoy_config_cluster_v3_Cluster_LbPolicy[_envoy_config_cluster_v3_Cluster_LbPolicy["CLUSTER_PROVIDED"] = 6] = "CLUSTER_PROVIDED";
    /**
     * Use the new :ref:`load_balancing_policy
     * <envoy_v3_api_field_config.cluster.v3.Cluster.load_balancing_policy>` field to determine the LB policy.
     * This has been deprecated in favor of using the :ref:`load_balancing_policy
     * <envoy_v3_api_field_config.cluster.v3.Cluster.load_balancing_policy>` field without
     * setting any value in :ref:`lb_policy<envoy_v3_api_field_config.cluster.v3.Cluster.lb_policy>`.
     */
    _envoy_config_cluster_v3_Cluster_LbPolicy[_envoy_config_cluster_v3_Cluster_LbPolicy["LOAD_BALANCING_POLICY_CONFIG"] = 7] = "LOAD_BALANCING_POLICY_CONFIG";
})(_envoy_config_cluster_v3_Cluster_LbPolicy = exports._envoy_config_cluster_v3_Cluster_LbPolicy || (exports._envoy_config_cluster_v3_Cluster_LbPolicy = {}));
// Original file: deps/envoy-api/envoy/config/cluster/v3/cluster.proto
/**
 * If NO_FALLBACK is selected, a result
 * equivalent to no healthy hosts is reported. If ANY_ENDPOINT is selected,
 * any cluster endpoint may be returned (subject to policy, health checks,
 * etc). If DEFAULT_SUBSET is selected, load balancing is performed over the
 * endpoints matching the values from the default_subset field.
 */
var _envoy_config_cluster_v3_Cluster_LbSubsetConfig_LbSubsetFallbackPolicy;
(function (_envoy_config_cluster_v3_Cluster_LbSubsetConfig_LbSubsetFallbackPolicy) {
    _envoy_config_cluster_v3_Cluster_LbSubsetConfig_LbSubsetFallbackPolicy[_envoy_config_cluster_v3_Cluster_LbSubsetConfig_LbSubsetFallbackPolicy["NO_FALLBACK"] = 0] = "NO_FALLBACK";
    _envoy_config_cluster_v3_Cluster_LbSubsetConfig_LbSubsetFallbackPolicy[_envoy_config_cluster_v3_Cluster_LbSubsetConfig_LbSubsetFallbackPolicy["ANY_ENDPOINT"] = 1] = "ANY_ENDPOINT";
    _envoy_config_cluster_v3_Cluster_LbSubsetConfig_LbSubsetFallbackPolicy[_envoy_config_cluster_v3_Cluster_LbSubsetConfig_LbSubsetFallbackPolicy["DEFAULT_SUBSET"] = 2] = "DEFAULT_SUBSET";
})(_envoy_config_cluster_v3_Cluster_LbSubsetConfig_LbSubsetFallbackPolicy = exports._envoy_config_cluster_v3_Cluster_LbSubsetConfig_LbSubsetFallbackPolicy || (exports._envoy_config_cluster_v3_Cluster_LbSubsetConfig_LbSubsetFallbackPolicy = {}));
// Original file: deps/envoy-api/envoy/config/cluster/v3/cluster.proto
var _envoy_config_cluster_v3_Cluster_LbSubsetConfig_LbSubsetMetadataFallbackPolicy;
(function (_envoy_config_cluster_v3_Cluster_LbSubsetConfig_LbSubsetMetadataFallbackPolicy) {
    /**
     * No fallback. Route metadata will be used as-is.
     */
    _envoy_config_cluster_v3_Cluster_LbSubsetConfig_LbSubsetMetadataFallbackPolicy[_envoy_config_cluster_v3_Cluster_LbSubsetConfig_LbSubsetMetadataFallbackPolicy["METADATA_NO_FALLBACK"] = 0] = "METADATA_NO_FALLBACK";
    /**
     * A special metadata key ``fallback_list`` will be used to provide variants of metadata to try.
     * Value of ``fallback_list`` key has to be a list. Every list element has to be a struct - it will
     * be merged with route metadata, overriding keys that appear in both places.
     * ``fallback_list`` entries will be used in order until a host is found.
     *
     * ``fallback_list`` key itself is removed from metadata before subset load balancing is performed.
     *
     * Example:
     *
     * for metadata:
     *
     * .. code-block:: yaml
     *
     * version: 1.0
     * fallback_list:
     * - version: 2.0
     * hardware: c64
     * - hardware: c32
     * - version: 3.0
     *
     * at first, metadata:
     *
     * .. code-block:: json
     *
     * {"version": "2.0", "hardware": "c64"}
     *
     * will be used for load balancing. If no host is found, metadata:
     *
     * .. code-block:: json
     *
     * {"version": "1.0", "hardware": "c32"}
     *
     * is next to try. If it still results in no host, finally metadata:
     *
     * .. code-block:: json
     *
     * {"version": "3.0"}
     *
     * is used.
     */
    _envoy_config_cluster_v3_Cluster_LbSubsetConfig_LbSubsetMetadataFallbackPolicy[_envoy_config_cluster_v3_Cluster_LbSubsetConfig_LbSubsetMetadataFallbackPolicy["FALLBACK_LIST"] = 1] = "FALLBACK_LIST";
})(_envoy_config_cluster_v3_Cluster_LbSubsetConfig_LbSubsetMetadataFallbackPolicy = exports._envoy_config_cluster_v3_Cluster_LbSubsetConfig_LbSubsetMetadataFallbackPolicy || (exports._envoy_config_cluster_v3_Cluster_LbSubsetConfig_LbSubsetMetadataFallbackPolicy = {}));
// Original file: deps/envoy-api/envoy/config/cluster/v3/cluster.proto
/**
 * Allows to override top level fallback policy per selector.
 */
var _envoy_config_cluster_v3_Cluster_LbSubsetConfig_LbSubsetSelector_LbSubsetSelectorFallbackPolicy;
(function (_envoy_config_cluster_v3_Cluster_LbSubsetConfig_LbSubsetSelector_LbSubsetSelectorFallbackPolicy) {
    /**
     * If NOT_DEFINED top level config fallback policy is used instead.
     */
    _envoy_config_cluster_v3_Cluster_LbSubsetConfig_LbSubsetSelector_LbSubsetSelectorFallbackPolicy[_envoy_config_cluster_v3_Cluster_LbSubsetConfig_LbSubsetSelector_LbSubsetSelectorFallbackPolicy["NOT_DEFINED"] = 0] = "NOT_DEFINED";
    /**
     * If NO_FALLBACK is selected, a result equivalent to no healthy hosts is reported.
     */
    _envoy_config_cluster_v3_Cluster_LbSubsetConfig_LbSubsetSelector_LbSubsetSelectorFallbackPolicy[_envoy_config_cluster_v3_Cluster_LbSubsetConfig_LbSubsetSelector_LbSubsetSelectorFallbackPolicy["NO_FALLBACK"] = 1] = "NO_FALLBACK";
    /**
     * If ANY_ENDPOINT is selected, any cluster endpoint may be returned
     * (subject to policy, health checks, etc).
     */
    _envoy_config_cluster_v3_Cluster_LbSubsetConfig_LbSubsetSelector_LbSubsetSelectorFallbackPolicy[_envoy_config_cluster_v3_Cluster_LbSubsetConfig_LbSubsetSelector_LbSubsetSelectorFallbackPolicy["ANY_ENDPOINT"] = 2] = "ANY_ENDPOINT";
    /**
     * If DEFAULT_SUBSET is selected, load balancing is performed over the
     * endpoints matching the values from the default_subset field.
     */
    _envoy_config_cluster_v3_Cluster_LbSubsetConfig_LbSubsetSelector_LbSubsetSelectorFallbackPolicy[_envoy_config_cluster_v3_Cluster_LbSubsetConfig_LbSubsetSelector_LbSubsetSelectorFallbackPolicy["DEFAULT_SUBSET"] = 3] = "DEFAULT_SUBSET";
    /**
     * If KEYS_SUBSET is selected, subset selector matching is performed again with metadata
     * keys reduced to
     * :ref:`fallback_keys_subset<envoy_v3_api_field_config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector.fallback_keys_subset>`.
     * It allows for a fallback to a different, less specific selector if some of the keys of
     * the selector are considered optional.
     */
    _envoy_config_cluster_v3_Cluster_LbSubsetConfig_LbSubsetSelector_LbSubsetSelectorFallbackPolicy[_envoy_config_cluster_v3_Cluster_LbSubsetConfig_LbSubsetSelector_LbSubsetSelectorFallbackPolicy["KEYS_SUBSET"] = 4] = "KEYS_SUBSET";
})(_envoy_config_cluster_v3_Cluster_LbSubsetConfig_LbSubsetSelector_LbSubsetSelectorFallbackPolicy = exports._envoy_config_cluster_v3_Cluster_LbSubsetConfig_LbSubsetSelector_LbSubsetSelectorFallbackPolicy || (exports._envoy_config_cluster_v3_Cluster_LbSubsetConfig_LbSubsetSelector_LbSubsetSelectorFallbackPolicy = {}));
//# sourceMappingURL=Cluster.js.map