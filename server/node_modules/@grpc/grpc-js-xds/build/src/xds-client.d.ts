import { StatusObject } from "@grpc/grpc-js";
import { XdsResourceType } from "./xds-resource-type/xds-resource-type";
import { XdsResourceName } from "./resources";
import { Node } from "./generated/envoy/config/core/v3/Node";
import { BootstrapInfo, XdsServerConfig } from "./xds-bootstrap";
import { Any__Output } from "./generated/google/protobuf/Any";
import { LoadStatsResponse__Output } from "./generated/envoy/service/load_stats/v3/LoadStatsResponse";
import { Locality__Output } from "./generated/envoy/config/core/v3/Locality";
export interface ResourceWatcherInterface {
    onGenericResourceChanged(resource: object): void;
    onError(status: StatusObject): void;
    onResourceDoesNotExist(): void;
}
export interface BasicWatcher<UpdateType> {
    onResourceChanged(resource: UpdateType): void;
    onError(status: StatusObject): void;
    onResourceDoesNotExist(): void;
}
export declare class Watcher<UpdateType> implements ResourceWatcherInterface {
    private internalWatcher;
    constructor(internalWatcher: BasicWatcher<UpdateType>);
    onGenericResourceChanged(resource: object): void;
    onError(status: StatusObject): void;
    onResourceDoesNotExist(): void;
}
export interface XdsClusterDropStats {
    addUncategorizedCallDropped(): void;
    addCallDropped(category: string): void;
}
export interface XdsClusterLocalityStats {
    addCallStarted(): void;
    addCallFinished(fail: boolean): void;
}
interface ClusterLocalityStats {
    locality: Locality__Output;
    callsStarted: number;
    callsSucceeded: number;
    callsFailed: number;
    callsInProgress: number;
    refcount: number;
}
interface ClusterLoadReport {
    callsDropped: Map<string, number>;
    uncategorizedCallsDropped: number;
    localityStats: Set<ClusterLocalityStats>;
    intervalStart: [number, number];
}
declare class ClusterLoadReportMap {
    private statsMap;
    get(clusterName: string, edsServiceName: string): ClusterLoadReport | undefined;
    /**
     * Get the indicated map entry if it exists, or create a new one if it does
     * not. Increments the refcount of that entry, so a call to this method
     * should correspond to a later call to unref
     * @param clusterName
     * @param edsServiceName
     * @returns
     */
    getOrCreate(clusterName: string, edsServiceName: string): ClusterLoadReport;
    entries(): IterableIterator<[
        {
            clusterName: string;
            edsServiceName: string;
        },
        ClusterLoadReport
    ]>;
    unref(clusterName: string, edsServiceName: string): void;
    get size(): number;
}
declare class XdsSingleServerClient {
    xdsClient: XdsClient;
    xdsServerConfig: XdsServerConfig;
    ignoreResourceDeletion: boolean;
    private adsBackoff;
    private lrsBackoff;
    private adsClient;
    private adsCallState;
    private lrsClient;
    private lrsCallState;
    clusterStatsMap: ClusterLoadReportMap;
    latestLrsSettings: LoadStatsResponse__Output | null;
    /**
     * The number of authorities that are using this client. Streams should only
     * be started if refcount > 0
     */
    private refcount;
    /**
     * Map of type to latest accepted version string for that type
     */
    resourceTypeVersionMap: Map<XdsResourceType, string>;
    constructor(xdsClient: XdsClient, bootstrapNode: Node, xdsServerConfig: XdsServerConfig);
    private handleAdsConnectivityStateUpdate;
    onAdsStreamReceivedMessage(): void;
    handleAdsStreamEnd(): void;
    private maybeStartAdsStream;
    onLrsStreamReceivedMessage(): void;
    handleLrsStreamEnd(): void;
    private maybeStartLrsStream;
    trace(text: string): void;
    subscribe(type: XdsResourceType, name: XdsResourceName): void;
    unsubscribe(type: XdsResourceType, name: XdsResourceName): void;
    ref(): void;
    unref(): void;
    addClusterDropStats(clusterName: string, edsServiceName: string): XdsClusterDropStats;
    removeClusterDropStats(clusterName: string, edsServiceName: string): void;
    addClusterLocalityStats(clusterName: string, edsServiceName: string, locality: Locality__Output): XdsClusterLocalityStats;
    removeClusterLocalityStats(clusterName: string, edsServiceName: string, locality: Locality__Output): void;
}
type ClientResourceStatus = 'REQUESTED' | 'DOES_NOT_EXIST' | 'ACKED' | 'NACKED';
interface ResourceMetadata {
    clientStatus: ClientResourceStatus;
    rawResource?: Any__Output;
    updateTime?: Date;
    version?: string;
    failedVersion?: string;
    failedDetails?: string;
    failedUpdateTime?: Date;
}
interface ResourceState {
    watchers: Set<ResourceWatcherInterface>;
    cachedResource: object | null;
    meta: ResourceMetadata;
    deletionIgnored: boolean;
}
interface AuthorityState {
    client: XdsSingleServerClient;
    /**
     * type -> key -> state
     */
    resourceMap: Map<XdsResourceType, Map<string, ResourceState>>;
}
export declare class XdsClient {
    /**
     * authority -> authority state
     */
    authorityStateMap: Map<string, AuthorityState>;
    private clients;
    private typeRegistry;
    private bootstrapInfo;
    constructor(bootstrapInfoOverride?: BootstrapInfo);
    private getBootstrapInfo;
    get adsNode(): Node | undefined;
    get lrsNode(): Node | undefined;
    private getOrCreateClient;
    private getClient;
    getResourceType(typeUrl: string): XdsResourceType | undefined;
    watchResource(type: XdsResourceType, name: string, watcher: ResourceWatcherInterface): void;
    cancelResourceWatch(type: XdsResourceType, name: string, watcher: ResourceWatcherInterface): void;
    addClusterDropStats(lrsServer: XdsServerConfig, clusterName: string, edsServiceName: string): XdsClusterDropStats;
    removeClusterDropStats(lrsServer: XdsServerConfig, clusterName: string, edsServiceName: string): void;
    addClusterLocalityStats(lrsServer: XdsServerConfig, clusterName: string, edsServiceName: string, locality: Locality__Output): XdsClusterLocalityStats;
    removeClusterLocalityStats(lrsServer: XdsServerConfig, clusterName: string, edsServiceName: string, locality: Locality__Output): void;
}
export declare function getSingletonXdsClient(): XdsClient;
export {};
