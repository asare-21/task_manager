"use strict";
/*
 * Copyright 2023 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.convertToLoadBalancingConfig = exports.registerLbPolicy = void 0;
// https://github.com/grpc/proposal/blob/master/A52-xds-custom-lb-policies.md
const grpc_js_1 = require("@grpc/grpc-js");
const TRACER_NAME = 'lb_policy_registry';
function trace(text) {
    grpc_js_1.experimental.trace(grpc_js_1.logVerbosity.DEBUG, TRACER_NAME, text);
}
const MAX_RECURSION_DEPTH = 16;
const registry = {};
function registerLbPolicy(typeUrl, converter) {
    registry[typeUrl] = { convertToLoadBalancingPolicy: converter };
}
exports.registerLbPolicy = registerLbPolicy;
function convertToLoadBalancingConfig(protoPolicy, recursionDepth = 0) {
    trace('Registry entries: [' + Object.keys(registry) + ']');
    if (recursionDepth > MAX_RECURSION_DEPTH) {
        throw new Error(`convertToLoadBalancingConfig: Max recursion depth ${MAX_RECURSION_DEPTH} reached`);
    }
    for (const policyCandidate of protoPolicy.policies) {
        trace('Attempting to parse config ' + JSON.stringify(policyCandidate));
        const extensionConfig = policyCandidate.typed_extension_config;
        if (!extensionConfig?.typed_config) {
            continue;
        }
        const typeUrl = extensionConfig.typed_config.type_url;
        trace('Attempting to parse config with type_url=' + typeUrl);
        let parseResult;
        if (typeUrl in registry) {
            try {
                parseResult = registry[typeUrl].convertToLoadBalancingPolicy(extensionConfig, childPolicy => convertToLoadBalancingConfig(childPolicy, recursionDepth + 1));
            }
            catch (e) {
                throw new Error(`Error parsing ${typeUrl} LoadBalancingPolicy named ${extensionConfig.name}: ${e.message}`);
            }
            if (parseResult) {
                return parseResult;
            }
            else {
                continue;
            }
        }
    }
    throw new Error('No registered LB policy found in list');
}
exports.convertToLoadBalancingConfig = convertToLoadBalancingConfig;
//# sourceMappingURL=lb-policy-registry.js.map