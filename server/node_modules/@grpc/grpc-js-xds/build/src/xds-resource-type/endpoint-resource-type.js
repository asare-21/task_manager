"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.EndpointResourceType = void 0;
const grpc_js_1 = require("@grpc/grpc-js");
const xds_resource_type_1 = require("./xds-resource-type");
const net_1 = require("net");
const resources_1 = require("../resources");
const TRACER_NAME = 'xds_client';
const UINT32_MAX = 0xFFFFFFFF;
function trace(text) {
    grpc_js_1.experimental.trace(grpc_js_1.logVerbosity.DEBUG, TRACER_NAME, text);
}
function localitiesEqual(a, b) {
    return a.region === b.region && a.sub_zone === b.sub_zone && a.zone === b.zone;
}
function addressesEqual(a, b) {
    return a.address === b.address && a.port_value === b.port_value;
}
class EndpointResourceType extends xds_resource_type_1.XdsResourceType {
    constructor() {
        super();
    }
    static get() {
        return EndpointResourceType.singleton;
    }
    getTypeUrl() {
        return 'envoy.config.endpoint.v3.ClusterLoadAssignment';
    }
    validateResource(message) {
        const seenLocalities = [];
        const seenAddresses = [];
        const priorityTotalWeights = new Map();
        for (const endpoint of message.endpoints) {
            if (!endpoint.locality) {
                trace('EDS validation: endpoint locality unset');
                return null;
            }
            for (const { locality, priority } of seenLocalities) {
                if (localitiesEqual(endpoint.locality, locality) && endpoint.priority === priority) {
                    trace('EDS validation: endpoint locality duplicated: ' + JSON.stringify(locality) + ', priority=' + priority);
                    return null;
                }
            }
            seenLocalities.push({ locality: endpoint.locality, priority: endpoint.priority });
            for (const lb of endpoint.lb_endpoints) {
                const socketAddress = lb.endpoint?.address?.socket_address;
                if (!socketAddress) {
                    trace('EDS validation: endpoint socket_address not set');
                    return null;
                }
                if (socketAddress.port_specifier !== 'port_value') {
                    trace('EDS validation: socket_address.port_specifier !== "port_value"');
                    return null;
                }
                if (!((0, net_1.isIPv4)(socketAddress.address) || (0, net_1.isIPv6)(socketAddress.address))) {
                    trace('EDS validation: address not a valid IPv4 or IPv6 address: ' + socketAddress.address);
                    return null;
                }
                for (const address of seenAddresses) {
                    if (addressesEqual(socketAddress, address)) {
                        trace('EDS validation: duplicate address seen: ' + address);
                        return null;
                    }
                }
                seenAddresses.push(socketAddress);
            }
            priorityTotalWeights.set(endpoint.priority, (priorityTotalWeights.get(endpoint.priority) ?? 0) + (endpoint.load_balancing_weight?.value ?? 0));
        }
        for (const totalWeight of priorityTotalWeights.values()) {
            if (totalWeight > UINT32_MAX) {
                trace('EDS validation: total weight > UINT32_MAX');
                return null;
            }
        }
        for (const priority of priorityTotalWeights.keys()) {
            if (priority > 0 && !priorityTotalWeights.has(priority - 1)) {
                trace('EDS validation: priorities not contiguous');
                return null;
            }
        }
        return message;
    }
    decode(context, resource) {
        if (resource.type_url !== resources_1.EDS_TYPE_URL) {
            throw new Error(`ADS Error: Invalid resource type ${resource.type_url}, expected ${resources_1.EDS_TYPE_URL}`);
        }
        const message = (0, resources_1.decodeSingleResource)(resources_1.EDS_TYPE_URL, resource.value);
        trace('Decoded raw resource of type ' + resources_1.EDS_TYPE_URL + ': ' + JSON.stringify(message, undefined, 2));
        const validatedMessage = this.validateResource(message);
        if (validatedMessage) {
            return {
                name: validatedMessage.cluster_name,
                value: validatedMessage
            };
        }
        else {
            return {
                name: message.cluster_name,
                error: 'Endpoint message validation failed'
            };
        }
    }
    allResourcesRequiredInSotW() {
        return false;
    }
    static startWatch(client, name, watcher) {
        client.watchResource(EndpointResourceType.get(), name, watcher);
    }
    static cancelWatch(client, name, watcher) {
        client.cancelResourceWatch(EndpointResourceType.get(), name, watcher);
    }
}
exports.EndpointResourceType = EndpointResourceType;
EndpointResourceType.singleton = new EndpointResourceType();
//# sourceMappingURL=endpoint-resource-type.js.map