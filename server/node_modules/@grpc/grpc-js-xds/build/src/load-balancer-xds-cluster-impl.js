"use strict";
/*
 * Copyright 2023 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.setup = void 0;
const grpc_js_1 = require("@grpc/grpc-js");
const xds_bootstrap_1 = require("./xds-bootstrap");
var registerLoadBalancerType = grpc_js_1.experimental.registerLoadBalancerType;
var endpointHasAddress = grpc_js_1.experimental.endpointHasAddress;
var subchannelAddressToString = grpc_js_1.experimental.subchannelAddressToString;
var PickResultType = grpc_js_1.experimental.PickResultType;
var ChildLoadBalancerHandler = grpc_js_1.experimental.ChildLoadBalancerHandler;
var createChildChannelControlHelper = grpc_js_1.experimental.createChildChannelControlHelper;
var selectLbConfigFromList = grpc_js_1.experimental.selectLbConfigFromList;
var BaseSubchannelWrapper = grpc_js_1.experimental.BaseSubchannelWrapper;
const TRACER_NAME = 'xds_cluster_impl';
function trace(text) {
    grpc_js_1.experimental.trace(grpc_js_1.logVerbosity.DEBUG, TRACER_NAME, text);
}
const TYPE_NAME = 'xds_cluster_impl';
const DEFAULT_MAX_CONCURRENT_REQUESTS = 1024;
function validateDropCategory(obj) {
    if (!('category' in obj && typeof obj.category === 'string')) {
        throw new Error('xds_cluster_impl config drop_categories entry must have a string field category');
    }
    if (!('requests_per_million' in obj && typeof obj.requests_per_million === 'number')) {
        throw new Error('xds_cluster_impl config drop_categories entry must have a number field requests_per_million');
    }
    return obj;
}
class XdsClusterImplLoadBalancingConfig {
    getLoadBalancerName() {
        return TYPE_NAME;
    }
    toJsonObject() {
        const jsonObj = {
            cluster: this.cluster,
            drop_categories: this.dropCategories,
            child_policy: [this.childPolicy.toJsonObject()],
            max_concurrent_requests: this.maxConcurrentRequests,
            eds_service_name: this.edsServiceName,
            lrs_load_reporting_server: this.lrsLoadReportingServer,
        };
        return {
            [TYPE_NAME]: jsonObj
        };
    }
    constructor(cluster, dropCategories, childPolicy, edsServiceName, lrsLoadReportingServer, maxConcurrentRequests) {
        this.cluster = cluster;
        this.dropCategories = dropCategories;
        this.childPolicy = childPolicy;
        this.edsServiceName = edsServiceName;
        this.lrsLoadReportingServer = lrsLoadReportingServer;
        this.maxConcurrentRequests = maxConcurrentRequests ?? DEFAULT_MAX_CONCURRENT_REQUESTS;
    }
    getCluster() {
        return this.cluster;
    }
    getEdsServiceName() {
        return this.edsServiceName;
    }
    getLrsLoadReportingServer() {
        return this.lrsLoadReportingServer;
    }
    getMaxConcurrentRequests() {
        return this.maxConcurrentRequests;
    }
    getDropCategories() {
        return this.dropCategories;
    }
    getChildPolicy() {
        return this.childPolicy;
    }
    static createFromJson(obj) {
        if (!('cluster' in obj && typeof obj.cluster === 'string')) {
            throw new Error('xds_cluster_impl config must have a string field cluster');
        }
        if (!('eds_service_name' in obj && typeof obj.eds_service_name === 'string')) {
            throw new Error('xds_cluster_impl config must have a string field eds_service_name');
        }
        if ('max_concurrent_requests' in obj && !(obj.max_concurrent_requests === undefined || typeof obj.max_concurrent_requests === 'number')) {
            throw new Error('xds_cluster_impl config max_concurrent_requests must be a number if provided');
        }
        if (!('drop_categories' in obj && Array.isArray(obj.drop_categories))) {
            throw new Error('xds_cluster_impl config must have an array field drop_categories');
        }
        if (!('child_policy' in obj && Array.isArray(obj.child_policy))) {
            throw new Error('xds_cluster_impl config must have an array field child_policy');
        }
        const childConfig = selectLbConfigFromList(obj.child_policy);
        if (!childConfig) {
            throw new Error('xds_cluster_impl config child_policy parsing failed');
        }
        let lrsServer = undefined;
        if (obj.lrs_load_reporting_server) {
            lrsServer = (0, xds_bootstrap_1.validateXdsServerConfig)(obj.lrs_load_reporting_server);
        }
        return new XdsClusterImplLoadBalancingConfig(obj.cluster, obj.drop_categories.map(validateDropCategory), childConfig, obj.eds_service_name, lrsServer, obj.max_concurrent_requests);
    }
}
class CallCounterMap {
    constructor() {
        this.callCounters = new Map();
    }
    startCall(key) {
        const currentValue = this.callCounters.get(key) ?? 0;
        this.callCounters.set(key, currentValue + 1);
    }
    endCall(key) {
        const currentValue = this.callCounters.get(key) ?? 0;
        if (currentValue - 1 <= 0) {
            this.callCounters.delete(key);
        }
        else {
            this.callCounters.set(key, currentValue - 1);
        }
    }
    getConcurrentRequests(key) {
        return this.callCounters.get(key) ?? 0;
    }
}
const callCounterMap = new CallCounterMap();
class LocalitySubchannelWrapper extends BaseSubchannelWrapper {
    constructor(child, statsObject) {
        super(child);
        this.statsObject = statsObject;
    }
    getStatsObject() {
        return this.statsObject;
    }
    getWrappedSubchannel() {
        return this.child;
    }
}
/**
 * This picker is responsible for implementing the drop configuration, and for
 * recording drop stats and per-locality stats.
 */
class XdsClusterImplPicker {
    constructor(originalPicker, callCounterMapKey, maxConcurrentRequests, dropCategories, clusterDropStats) {
        this.originalPicker = originalPicker;
        this.callCounterMapKey = callCounterMapKey;
        this.maxConcurrentRequests = maxConcurrentRequests;
        this.dropCategories = dropCategories;
        this.clusterDropStats = clusterDropStats;
    }
    checkForMaxConcurrentRequestsDrop() {
        return callCounterMap.getConcurrentRequests(this.callCounterMapKey) >= this.maxConcurrentRequests;
    }
    checkForDrop() {
        for (const dropCategory of this.dropCategories) {
            if (Math.random() * 1000000 < dropCategory.requests_per_million) {
                return dropCategory.category;
            }
        }
        return null;
    }
    pick(pickArgs) {
        let details = null;
        if (this.checkForMaxConcurrentRequestsDrop()) {
            details = 'Call dropped by load balancing policy.';
            this.clusterDropStats?.addUncategorizedCallDropped();
        }
        else {
            const category = this.checkForDrop();
            if (category !== null) {
                details = `Call dropped by load balancing policy. Category: ${category}`;
                this.clusterDropStats?.addCallDropped(category);
            }
        }
        if (details === null) {
            const originalPick = this.originalPicker.pick(pickArgs);
            const pickSubchannel = originalPick.subchannel ? originalPick.subchannel : null;
            return {
                pickResultType: originalPick.pickResultType,
                status: originalPick.status,
                subchannel: pickSubchannel?.getWrappedSubchannel() ?? null,
                onCallStarted: () => {
                    originalPick.onCallStarted?.();
                    pickSubchannel?.getStatsObject()?.addCallStarted();
                    callCounterMap.startCall(this.callCounterMapKey);
                },
                onCallEnded: status => {
                    originalPick.onCallEnded?.(status);
                    pickSubchannel?.getStatsObject()?.addCallFinished(status !== grpc_js_1.status.OK);
                    callCounterMap.endCall(this.callCounterMapKey);
                }
            };
        }
        else {
            return {
                pickResultType: PickResultType.DROP,
                status: {
                    code: grpc_js_1.status.UNAVAILABLE,
                    details: details,
                    metadata: new grpc_js_1.Metadata(),
                },
                subchannel: null,
                onCallEnded: null,
                onCallStarted: null
            };
        }
    }
}
function getCallCounterMapKey(cluster, edsServiceName) {
    return `{${cluster},${edsServiceName ?? ''}}`;
}
class XdsClusterImplBalancer {
    constructor(channelControlHelper, options) {
        this.channelControlHelper = channelControlHelper;
        this.lastestEndpointList = null;
        this.latestConfig = null;
        this.clusterDropStats = null;
        this.xdsClient = null;
        this.childBalancer = new ChildLoadBalancerHandler(createChildChannelControlHelper(channelControlHelper, {
            createSubchannel: (subchannelAddress, subchannelArgs) => {
                if (!this.xdsClient || !this.latestConfig || !this.lastestEndpointList) {
                    throw new Error('xds_cluster_impl: invalid state: createSubchannel called with xdsClient or latestConfig not populated');
                }
                const wrapperChild = channelControlHelper.createSubchannel(subchannelAddress, subchannelArgs);
                let locality = null;
                for (const endpoint of this.lastestEndpointList) {
                    if (endpointHasAddress(endpoint, subchannelAddress)) {
                        locality = endpoint.locality;
                    }
                }
                if (locality === null) {
                    trace('Not reporting load for address ' + subchannelAddressToString(subchannelAddress) + ' because it has unknown locality.');
                    return wrapperChild;
                }
                const lrsServer = this.latestConfig.getLrsLoadReportingServer();
                let statsObj = null;
                if (lrsServer) {
                    statsObj = this.xdsClient.addClusterLocalityStats(lrsServer, this.latestConfig.getCluster(), this.latestConfig.getEdsServiceName(), locality);
                }
                return new LocalitySubchannelWrapper(wrapperChild, statsObj);
            },
            updateState: (connectivityState, originalPicker) => {
                if (this.latestConfig === null) {
                    channelControlHelper.updateState(connectivityState, originalPicker);
                }
                else {
                    const picker = new XdsClusterImplPicker(originalPicker, getCallCounterMapKey(this.latestConfig.getCluster(), this.latestConfig.getEdsServiceName()), this.latestConfig.getMaxConcurrentRequests(), this.latestConfig.getDropCategories(), this.clusterDropStats);
                    channelControlHelper.updateState(connectivityState, picker);
                }
            }
        }), options);
    }
    updateAddressList(endpointList, lbConfig, attributes) {
        if (!(lbConfig instanceof XdsClusterImplLoadBalancingConfig)) {
            trace('Discarding address list update with unrecognized config ' + JSON.stringify(lbConfig.toJsonObject(), undefined, 2));
            return;
        }
        trace('Received update with config: ' + JSON.stringify(lbConfig, undefined, 2));
        this.lastestEndpointList = endpointList;
        this.latestConfig = lbConfig;
        this.xdsClient = attributes.xdsClient;
        if (lbConfig.getLrsLoadReportingServer()) {
            this.clusterDropStats = this.xdsClient.addClusterDropStats(lbConfig.getLrsLoadReportingServer(), lbConfig.getCluster(), lbConfig.getEdsServiceName() ?? '');
        }
        this.childBalancer.updateAddressList(endpointList, lbConfig.getChildPolicy(), attributes);
    }
    exitIdle() {
        this.childBalancer.exitIdle();
    }
    resetBackoff() {
        this.childBalancer.resetBackoff();
    }
    destroy() {
        this.childBalancer.destroy();
    }
    getTypeName() {
        return TYPE_NAME;
    }
}
function setup() {
    registerLoadBalancerType(TYPE_NAME, XdsClusterImplBalancer, XdsClusterImplLoadBalancingConfig);
}
exports.setup = setup;
//# sourceMappingURL=load-balancer-xds-cluster-impl.js.map