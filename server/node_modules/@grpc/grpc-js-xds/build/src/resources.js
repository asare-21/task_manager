"use strict";
/*
 * Copyright 2021 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.xdsResourceNameToString = exports.parseXdsResourceName = exports.decodeSingleResource = exports.CLUSTER_CONFIG_TYPE_URL = exports.HTTP_CONNECTION_MANGER_TYPE_URL = exports.RDS_TYPE_URL = exports.LDS_TYPE_URL = exports.CDS_TYPE_URL = exports.EDS_TYPE_URL = void 0;
const vscode_uri_1 = require("vscode-uri");
/* Since we are using an internal function from @grpc/proto-loader, we also
 * need the top-level import to perform some setup operations. */
require("@grpc/proto-loader");
// This is a non-public, unstable API, but it's very convenient
const util_1 = require("@grpc/proto-loader/build/src/util");
const environment_1 = require("./environment");
exports.EDS_TYPE_URL = 'type.googleapis.com/envoy.config.endpoint.v3.ClusterLoadAssignment';
exports.CDS_TYPE_URL = 'type.googleapis.com/envoy.config.cluster.v3.Cluster';
exports.LDS_TYPE_URL = 'type.googleapis.com/envoy.config.listener.v3.Listener';
exports.RDS_TYPE_URL = 'type.googleapis.com/envoy.config.route.v3.RouteConfiguration';
exports.HTTP_CONNECTION_MANGER_TYPE_URL = 'type.googleapis.com/envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager';
exports.CLUSTER_CONFIG_TYPE_URL = 'type.googleapis.com/envoy.extensions.clusters.aggregate.v3.ClusterConfig';
const resourceRoot = (0, util_1.loadProtosWithOptionsSync)([
    'envoy/config/listener/v3/listener.proto',
    'envoy/config/route/v3/route.proto',
    'envoy/config/cluster/v3/cluster.proto',
    'envoy/config/endpoint/v3/endpoint.proto',
    'envoy/extensions/filters/network/http_connection_manager/v3/http_connection_manager.proto',
    'envoy/extensions/clusters/aggregate/v3/cluster.proto'
], {
    keepCase: true,
    includeDirs: [
        // Paths are relative to src/build
        __dirname + '/../../deps/envoy-api/',
        __dirname + '/../../deps/xds/',
        __dirname + '/../../deps/googleapis/',
        __dirname + '/../../deps/protoc-gen-validate/',
    ],
});
const toObjectOptions = {
    longs: String,
    enums: String,
    defaults: true,
    oneofs: true
};
function decodeSingleResource(targetTypeUrl, message) {
    const name = targetTypeUrl.substring(targetTypeUrl.lastIndexOf('/') + 1);
    const type = resourceRoot.lookup(name);
    if (type) {
        const decodedMessage = type.decode(message);
        return decodedMessage.$type.toObject(decodedMessage, toObjectOptions);
    }
    else {
        throw new Error(`ADS Error: unknown resource type ${targetTypeUrl}`);
    }
}
exports.decodeSingleResource = decodeSingleResource;
function stripStringPrefix(value, prefix) {
    if (value.startsWith(prefix)) {
        return value.substring(prefix.length);
    }
    else {
        return value;
    }
}
function parseXdsResourceName(name, typeUrl) {
    if (!environment_1.EXPERIMENTAL_FEDERATION || !name.startsWith('xdstp:')) {
        return {
            authority: 'old:',
            key: name
        };
    }
    const uri = vscode_uri_1.URI.parse(name);
    const pathComponents = stripStringPrefix(uri.path, '/').split('/');
    if (pathComponents[0] !== typeUrl) {
        throw new Error('xdstp URI path must indicate valid xDS resource type.');
    }
    let queryString;
    if (uri.query.length > 0) {
        const queryParams = uri.query.split('&');
        queryParams.sort();
        queryString = '?' + queryParams.join('&');
    }
    else {
        queryString = '';
    }
    return {
        authority: uri.authority,
        key: `${pathComponents.slice(1).join('/')}${queryString}`
    };
}
exports.parseXdsResourceName = parseXdsResourceName;
function xdsResourceNameToString(name, typeUrl) {
    if (name.authority === 'old:') {
        return name.key;
    }
    return `xdstp://${name.authority}/${typeUrl}/${name.key}`;
}
exports.xdsResourceNameToString = xdsResourceNameToString;
//# sourceMappingURL=resources.js.map