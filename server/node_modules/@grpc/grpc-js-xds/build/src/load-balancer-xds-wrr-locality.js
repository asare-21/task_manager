"use strict";
/*
 * Copyright 2023 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.setup = void 0;
// https://github.com/grpc/proposal/blob/master/A52-xds-custom-lb-policies.md
const grpc_js_1 = require("@grpc/grpc-js");
const util_1 = require("@grpc/proto-loader/build/src/util");
const load_balancer_priority_1 = require("./load-balancer-priority");
const load_balancer_xds_cluster_resolver_1 = require("./load-balancer-xds-cluster-resolver");
var ChildLoadBalancerHandler = grpc_js_1.experimental.ChildLoadBalancerHandler;
var parseLoadBalancingConfig = grpc_js_1.experimental.parseLoadBalancingConfig;
var registerLoadBalancerType = grpc_js_1.experimental.registerLoadBalancerType;
const lb_policy_registry_1 = require("./lb-policy-registry");
const TRACER_NAME = 'xds_wrr_locality';
function trace(text) {
    grpc_js_1.experimental.trace(grpc_js_1.logVerbosity.DEBUG, TRACER_NAME, text);
}
const TYPE_NAME = 'xds_wrr_locality';
class XdsWrrLocalityLoadBalancingConfig {
    getLoadBalancerName() {
        return TYPE_NAME;
    }
    toJsonObject() {
        return {
            [TYPE_NAME]: {
                child_policy: this.childPolicy
            }
        };
    }
    constructor(childPolicy) {
        this.childPolicy = childPolicy;
    }
    getChildPolicy() {
        return this.childPolicy;
    }
    static createFromJson(obj) {
        if (!('child_policy' in obj && Array.isArray(obj.child_policy))) {
            throw new Error('xds_wrr_locality config must have a child_policy array');
        }
        return new XdsWrrLocalityLoadBalancingConfig(obj.child_policy);
    }
}
class XdsWrrLocalityLoadBalancer {
    constructor(channelControlHelper, options) {
        this.channelControlHelper = channelControlHelper;
        this.childBalancer = new ChildLoadBalancerHandler(channelControlHelper, options);
    }
    updateAddressList(endpointList, lbConfig, attributes) {
        if (!(lbConfig instanceof XdsWrrLocalityLoadBalancingConfig)) {
            trace('Discarding address list update with unrecognized config ' + JSON.stringify(lbConfig, undefined, 2));
            return;
        }
        const targets = {};
        for (const address of endpointList) {
            if (!(0, load_balancer_priority_1.isLocalityEndpoint)(address)) {
                return;
            }
            const localityName = (0, load_balancer_xds_cluster_resolver_1.localityToName)(address.locality);
            if (!(localityName in targets)) {
                targets[localityName] = {
                    child_policy: lbConfig.getChildPolicy(),
                    weight: address.localityWeight
                };
            }
        }
        const childConfig = {
            weighted_target: {
                targets: targets
            }
        };
        this.childBalancer.updateAddressList(endpointList, parseLoadBalancingConfig(childConfig), attributes);
    }
    exitIdle() {
        this.childBalancer.exitIdle();
    }
    resetBackoff() {
        this.childBalancer.resetBackoff();
    }
    destroy() {
        this.childBalancer.destroy();
    }
    getTypeName() {
        return TYPE_NAME;
    }
}
const WRR_LOCALITY_TYPE_URL = 'type.googleapis.com/envoy.extensions.load_balancing_policies.wrr_locality.v3.WrrLocality';
const resourceRoot = (0, util_1.loadProtosWithOptionsSync)([
    'envoy/extensions/load_balancing_policies/wrr_locality/v3/wrr_locality.proto'
], {
    keepCase: true,
    includeDirs: [
        // Paths are relative to src/build
        __dirname + '/../../deps/envoy-api/',
        __dirname + '/../../deps/xds/',
        __dirname + '/../../deps/protoc-gen-validate'
    ],
});
const toObjectOptions = {
    longs: String,
    enums: String,
    defaults: true,
    oneofs: true
};
function decodeWrrLocality(message) {
    const name = message.type_url.substring(message.type_url.lastIndexOf('/') + 1);
    const type = resourceRoot.lookup(name);
    if (type) {
        const decodedMessage = type.decode(message.value);
        return decodedMessage.$type.toObject(decodedMessage, toObjectOptions);
    }
    else {
        throw new Error(`TypedStruct parsing error: unexpected type URL ${message.type_url}`);
    }
}
function convertToLoadBalancingPolicy(protoPolicy, selectChildPolicy) {
    if (protoPolicy.typed_config?.type_url !== WRR_LOCALITY_TYPE_URL) {
        throw new Error(`WRR Locality LB policy parsing error: unexpected type URL ${protoPolicy.typed_config?.type_url}`);
    }
    const wrrLocalityMessage = decodeWrrLocality(protoPolicy.typed_config);
    if (!wrrLocalityMessage.endpoint_picking_policy) {
        throw new Error('WRR Locality LB parsing error: no endpoint_picking_policy specified');
    }
    return {
        [TYPE_NAME]: {
            child_policy: [selectChildPolicy(wrrLocalityMessage.endpoint_picking_policy)]
        }
    };
}
function setup() {
    registerLoadBalancerType(TYPE_NAME, XdsWrrLocalityLoadBalancer, XdsWrrLocalityLoadBalancingConfig);
    (0, lb_policy_registry_1.registerLbPolicy)(WRR_LOCALITY_TYPE_URL, convertToLoadBalancingPolicy);
}
exports.setup = setup;
//# sourceMappingURL=load-balancer-xds-wrr-locality.js.map