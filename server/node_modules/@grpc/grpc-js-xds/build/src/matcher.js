"use strict";
/*
 * Copyright 2021 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.FullMatcher = exports.PathSafeRegexValueMatcher = exports.PathExactValueMatcher = exports.PathPrefixValueMatcher = exports.HeaderMatcher = exports.RejectValueMatcher = exports.ContainsValueMatcher = exports.SuffixValueMatcher = exports.PrefixValueMatcher = exports.PresentValueMatcher = exports.RangeValueMatcher = exports.SafeRegexValueMatcher = exports.ExactValueMatcher = void 0;
const re2_wasm_1 = require("re2-wasm");
const fraction_1 = require("./fraction");
class ExactValueMatcher {
    constructor(targetValue, ignoreCase) {
        this.targetValue = targetValue;
        this.ignoreCase = ignoreCase;
    }
    apply(value) {
        if (this.ignoreCase) {
            return value.toLowerCase() === this.targetValue.toLowerCase();
        }
        else {
            return value === this.targetValue;
        }
    }
    toString() {
        return 'Exact(' + this.targetValue + ', ignore_case=' + this.ignoreCase + ')';
    }
}
exports.ExactValueMatcher = ExactValueMatcher;
class SafeRegexValueMatcher {
    constructor(targetRegex) {
        this.targetRegexImpl = new re2_wasm_1.RE2(`^${targetRegex}$`, 'u');
    }
    apply(value) {
        return this.targetRegexImpl.test(value);
    }
    toString() {
        return 'SafeRegex(' + this.targetRegexImpl.toString() + ')';
    }
}
exports.SafeRegexValueMatcher = SafeRegexValueMatcher;
const numberRegex = new re2_wasm_1.RE2(/^-?\d+$/u);
class RangeValueMatcher {
    constructor(start, end) {
        this.start = start;
        this.end = end;
    }
    apply(value) {
        if (!numberRegex.test(value)) {
            return false;
        }
        const numberValue = BigInt(value);
        return this.start <= numberValue && numberValue < this.end;
    }
    toString() {
        return 'Range(' + this.start + ', ' + this.end + ')';
    }
}
exports.RangeValueMatcher = RangeValueMatcher;
class PresentValueMatcher {
    constructor() { }
    apply(value) {
        return true;
    }
    toString() {
        return 'Present()';
    }
}
exports.PresentValueMatcher = PresentValueMatcher;
class PrefixValueMatcher {
    constructor(prefix, ignoreCase) {
        this.prefix = prefix;
        this.ignoreCase = ignoreCase;
    }
    apply(value) {
        if (this.ignoreCase) {
            return value.toLowerCase().startsWith(this.prefix.toLowerCase());
        }
        else {
            return value.startsWith(this.prefix);
        }
    }
    toString() {
        return 'Prefix(' + this.prefix + ', ignore_case=' + this.ignoreCase + ')';
    }
}
exports.PrefixValueMatcher = PrefixValueMatcher;
class SuffixValueMatcher {
    constructor(suffix, ignoreCase) {
        this.suffix = suffix;
        this.ignoreCase = ignoreCase;
    }
    apply(value) {
        if (this.ignoreCase) {
            return value.toLowerCase().endsWith(this.suffix.toLowerCase());
        }
        else {
            return value.endsWith(this.suffix);
        }
    }
    toString() {
        return 'Suffix(' + this.suffix + ', ignore_case=' + this.ignoreCase + ')';
    }
}
exports.SuffixValueMatcher = SuffixValueMatcher;
class ContainsValueMatcher {
    constructor(contains, ignoreCase) {
        this.contains = contains;
        this.ignoreCase = ignoreCase;
    }
    apply(value) {
        if (this.ignoreCase) {
            return value.toLowerCase().includes(this.contains.toLowerCase());
        }
        else {
            return value.includes(this.contains);
        }
    }
    toString() {
        return 'Contains(' + this.contains + +', ignore_case=' + this.ignoreCase + ')';
    }
}
exports.ContainsValueMatcher = ContainsValueMatcher;
class RejectValueMatcher {
    constructor() { }
    apply(value) {
        return false;
    }
    toString() {
        return 'Reject()';
    }
}
exports.RejectValueMatcher = RejectValueMatcher;
class HeaderMatcher {
    constructor(headerName, valueMatcher, invertMatch) {
        this.headerName = headerName;
        this.valueMatcher = valueMatcher;
        this.invertMatch = invertMatch;
    }
    applyHelper(methodName, metadata) {
        if (this.headerName.endsWith('-bin')) {
            return false;
        }
        let value;
        if (this.headerName === 'content-type') {
            value = 'application/grpc';
        }
        else {
            const valueArray = metadata.get(this.headerName);
            if (valueArray.length === 0) {
                return false;
            }
            else {
                value = valueArray.join(',');
            }
        }
        return this.valueMatcher.apply(value);
    }
    apply(methodName, metadata) {
        const result = this.applyHelper(methodName, metadata);
        if (this.invertMatch) {
            return !result;
        }
        else {
            return result;
        }
    }
    toString() {
        return 'HeaderMatch(' + this.headerName + ', ' + this.valueMatcher.toString() + ')';
    }
}
exports.HeaderMatcher = HeaderMatcher;
class PathPrefixValueMatcher {
    constructor(prefix, caseInsensitive) {
        this.prefix = prefix;
        this.caseInsensitive = caseInsensitive;
    }
    apply(value) {
        if (this.caseInsensitive) {
            return value.toLowerCase().startsWith(this.prefix.toLowerCase());
        }
        else {
            return value.startsWith(this.prefix);
        }
    }
    toString() {
        return 'Prefix(' + this.prefix + ', ' + this.caseInsensitive + ')';
    }
}
exports.PathPrefixValueMatcher = PathPrefixValueMatcher;
class PathExactValueMatcher {
    constructor(targetValue, caseInsensitive) {
        this.targetValue = targetValue;
        this.caseInsensitive = caseInsensitive;
    }
    apply(value) {
        if (this.caseInsensitive) {
            return value.toLowerCase().startsWith(this.targetValue.toLowerCase());
        }
        else {
            return value === this.targetValue;
        }
    }
    toString() {
        return 'Exact(' + this.targetValue + ', ' + this.caseInsensitive + ')';
    }
}
exports.PathExactValueMatcher = PathExactValueMatcher;
class PathSafeRegexValueMatcher {
    constructor(targetRegex) {
        this.targetRegexImpl = new re2_wasm_1.RE2(`^${targetRegex}$`, 'u');
    }
    apply(value) {
        return this.targetRegexImpl.test(value);
    }
    toString() {
        return 'SafeRegex(' + this.targetRegexImpl.toString() + ')';
    }
}
exports.PathSafeRegexValueMatcher = PathSafeRegexValueMatcher;
class FullMatcher {
    constructor(pathMatcher, headerMatchers, fraction) {
        this.pathMatcher = pathMatcher;
        this.headerMatchers = headerMatchers;
        this.fraction = fraction;
    }
    apply(methodName, metadata) {
        if (!this.pathMatcher.apply(methodName)) {
            return false;
        }
        if (!this.headerMatchers.every(matcher => matcher.apply(methodName, metadata))) {
            return false;
        }
        if (this.fraction === null) {
            return true;
        }
        else {
            const randomNumber = Math.random() * this.fraction.denominator;
            return randomNumber < this.fraction.numerator;
        }
    }
    toString() {
        return `path: ${this.pathMatcher}
    headers: ${this.headerMatchers.map(matcher => matcher.toString()).join('\n\t')}
    fraction: ${this.fraction ? (0, fraction_1.fractionToString)(this.fraction) : 'none'}`;
    }
}
exports.FullMatcher = FullMatcher;
//# sourceMappingURL=matcher.js.map